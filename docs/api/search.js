window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "arg", "modulename": "arg", "kind": "module", "doc": "<p>This module contains the game entry point. It is responsible for setting up\nPygame, Pygame GUI, the game state machine, and any other necessary components\nbefore invoking the initial game state handler.</p>\n\n<p>ARG is a finite state machine; each \"screen\" that gets drawn to the pygame\nwindow is represented by its own state, which is responsible for drawing the\ngame UI and moving components accordingly.</p>\n"}, {"fullname": "arg.load_asset", "modulename": "arg", "qualname": "load_asset", "kind": "function", "doc": "<p>Load an asset by name from the default assets directory and return a\nPygame surface which can be blitted to the main window as necessary.\nThis function should be used instead of <code>pygame.image.load()</code> because all\nassets live in the same place, and if that place changes, then only this\nfunction has to be modified, not every single place an asset is used.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">asset</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pygame</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>:</span></span>", "funcdef": "def"}, {"fullname": "arg.main", "modulename": "arg", "qualname": "main", "kind": "function", "doc": "<p>The game entry function. All initial setup and final teardown\nhappens here.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "arithmetic", "modulename": "arithmetic", "kind": "module", "doc": "<p>Arithmetic prompt and answer handling.</p>\n"}, {"fullname": "arithmetic.generate_arithmetic", "modulename": "arithmetic", "qualname": "generate_arithmetic", "kind": "function", "doc": "<p>Generate a random arithmetic problem that ensures the answer to the random\nproblem is an integer. This function returns a tuple whose first value is\nthe string representation of the simple arithmetic problem, and whose\nsecond value is the numeric solution to the problem, which should be used\nto check the user input against.</p>\n\n<p>A previous iteration of this module provided a separate function for\nactually solving the arithmetic problems generated by this function, but\nfor our purposes, we only need the display string for the equation and its\nsolution.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> (&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;float&#x27;&gt;):</span></span>", "funcdef": "def"}, {"fullname": "game_state", "modulename": "game_state", "kind": "module", "doc": "<p>The game state machine requires a number of components to be useful:</p>\n\n<ul>\n<li><code>GameState</code>: An enumeration of all the possible game states. This enumeration\nis used by the main event loop to keep track of which state handler to invoke,\nas well as by the state handlers themselves to signal state transitions.</li>\n<li><code>StateHandlerContext</code>: A simple data object that stores the game context,\nwhich is passed to each state handler function when it is being invoked.</li>\n<li><code>StateHandler</code>: A simple interface that implements a state handler. State\nhandlers are expected to adhere to this interface, and may implement any or no\nfunctions. Note that they should always call their parent functions listed\nin the interface, because these parent functions perform useful logic.</li>\n</ul>\n"}, {"fullname": "game_state.GameState", "modulename": "game_state", "qualname": "GameState", "kind": "class", "doc": "<p>The game itself may be in any of the following states:</p>\n"}, {"fullname": "game_state.GameState.GAME_QUIT", "modulename": "game_state", "qualname": "GameState.GAME_QUIT", "kind": "variable", "doc": "<p>The program is ending and should exit as quickly as possible.</p>\n", "default_value": "0"}, {"fullname": "game_state.GameState.MAIN_MENU", "modulename": "game_state", "qualname": "GameState.MAIN_MENU", "kind": "variable", "doc": "<p>The game is displaying the main menu and waiting for the user to make\na choice.</p>\n", "default_value": "1"}, {"fullname": "game_state.GameState.LEVEL_PLAY", "modulename": "game_state", "qualname": "GameState.LEVEL_PLAY", "kind": "variable", "doc": "<p>The game is currently being played. The user is making moves.</p>\n", "default_value": "2"}, {"fullname": "game_state.GameState.LEVEL_PAUSE", "modulename": "game_state", "qualname": "GameState.LEVEL_PAUSE", "kind": "variable", "doc": "<p>The game is paused. It is waiting for user input before resuming.</p>\n", "default_value": "3"}, {"fullname": "game_state.GameState.LEVEL_END", "modulename": "game_state", "qualname": "GameState.LEVEL_END", "kind": "variable", "doc": "<p>The current game has ended, either because the user hit an obstacle,\nor because a question was incorrectly answered.</p>\n", "default_value": "4"}, {"fullname": "game_state.GameState.DIFFICULTY", "modulename": "game_state", "qualname": "GameState.DIFFICULTY", "kind": "variable", "doc": "<p>The game is displaying the Difficulty meters for the MATH mode and\nwaiting for the user to make a choice</p>\n", "default_value": "5"}, {"fullname": "game_state.GameState.SCORE", "modulename": "game_state", "qualname": "GameState.SCORE", "kind": "variable", "doc": "<p>The game is displaying the recent scores</p>\n", "default_value": "6"}, {"fullname": "game_state.GameState.GAME_MODE", "modulename": "game_state", "qualname": "GameState.GAME_MODE", "kind": "variable", "doc": "<p>The game is displaying the mode select screen, which allows users to\nselect between math and flashcard mode.</p>\n", "default_value": "7"}, {"fullname": "game_state.StateHandlerContext", "modulename": "game_state", "qualname": "StateHandlerContext", "kind": "class", "doc": "<p>The state handler context is populated by the main state machine event\nloop, and is provided to state handlers so that they have easy access to\neverything necessary to draw to the screen, process user input, and update\nthe game state.</p>\n\n<p>The state machine is run iteratively at a fixed frame rate. A\n<code>StateHandlerContext</code> gets generated for each and every frame that is\nrendered. During each iteration, all events are collected and passed into\nthe context so that handlers can handle any events that may have passed\nsince the handler function was last executed.</p>\n"}, {"fullname": "game_state.StateHandlerContext.__init__", "modulename": "game_state", "qualname": "StateHandlerContext.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">GameState</span>,</span><span class=\"param\">\t<span class=\"n\">events</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">pygame</span><span class=\"o\">.</span><span class=\"n\">event</span><span class=\"o\">.</span><span class=\"n\">Event</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">window</span><span class=\"p\">:</span> <span class=\"n\">pygame</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>,</span><span class=\"param\">\t<span class=\"n\">gui</span><span class=\"p\">:</span> <span class=\"n\">pygame_gui</span><span class=\"o\">.</span><span class=\"n\">ui_manager</span><span class=\"o\">.</span><span class=\"n\">UIManager</span>,</span><span class=\"param\">\t<span class=\"n\">delta</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">storage</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span>)</span>"}, {"fullname": "game_state.StateHandlerContext.get_state", "modulename": "game_state", "qualname": "StateHandlerContext.get_state", "kind": "function", "doc": "<p>Get the current game state. Note that this is not always the state\nthat the currently running state handler was registered to handle. See\n<code>StateHandler</code> for more details.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">GameState</span>:</span></span>", "funcdef": "def"}, {"fullname": "game_state.StateHandlerContext.get_events", "modulename": "game_state", "qualname": "StateHandlerContext.get_events", "kind": "function", "doc": "<p>Get a list of Pygame events that have taken place since the last\niteration. Each fired event only shows up in this list exactly once,\nso it is recommended to iterate over it during each function call and\nprocess the events that need to be dealt with as soon as they are\nfired.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">pygame</span><span class=\"o\">.</span><span class=\"n\">event</span><span class=\"o\">.</span><span class=\"n\">Event</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "game_state.StateHandlerContext.get_window", "modulename": "game_state", "qualname": "StateHandlerContext.get_window", "kind": "function", "doc": "<p>Get the Pygame drawing surface onto which all game components are\nblitted. This surface represents the entire screen area, so each state\nhandler can draw anywhere on the screen and update the entire screen\nas necessary. Note that individual handlers don't have to update the\ndisplay by calling out to pygame explicitly; this is all handled by the\nstate machine event loop. State handlers must only blit everything onto\nthis surface.</p>\n\n<p>Note that the window is not preserved across frames; each state handler\nwill have to re-draw the entire frame on every iteration of the state\nmachine. By default, each frame is filled in solid black, so if there\nare black parts on the window that a state handler did not draw, it is\nsimply because the state handler did not blit anything over the empty\nframe in that location.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pygame</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>:</span></span>", "funcdef": "def"}, {"fullname": "game_state.StateHandlerContext.get_gui", "modulename": "game_state", "qualname": "StateHandlerContext.get_gui", "kind": "function", "doc": "<p>This game utilizes Pygame GUI for some user inputs. If a state handler\nmust register components, it should do so with this <code>UIManager</code>, which\nis automatically managed and updated by the state machine loop.</p>\n\n<p>If a state handler is going to register GUI components, it should do so\nonly once when the state is entered&mdash;not iteratively. Note that\nby default, the <code>UIManager</code> is cleared automatically on every state\nchange.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pygame_gui</span><span class=\"o\">.</span><span class=\"n\">ui_manager</span><span class=\"o\">.</span><span class=\"n\">UIManager</span>:</span></span>", "funcdef": "def"}, {"fullname": "game_state.StateHandlerContext.get_delta", "modulename": "game_state", "qualname": "StateHandlerContext.get_delta", "kind": "function", "doc": "<p>Get the amount of time that has passed (in <em>seconds</em>) since the last\ninvocation of a state handler. This is effectively the time since the\nlast frame was rendered, and should be used to compute object motion in\na frame rate-independent manner, because the frame rate may not always\nbe steady on all platforms.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "game_state.StateHandlerContext.get_storage", "modulename": "game_state", "qualname": "StateHandlerContext.get_storage", "kind": "function", "doc": "<p>Get a dictionary that is accessible to all state handlers. This storage\ndictionary can be in any format agreed upon by the state handlers, and\nis used to pass data between them. State handlers can process the\nstorage in their <code>on_enter()</code> and <code>on_exit()</code> functions.</p>\n\n<p>State handlers should make an effort to refrain from storing internal\ndata in the context storage. This storage should be reserved only for\nexporting data to other state handlers.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "game_state.StateHandler", "modulename": "game_state", "qualname": "StateHandler", "kind": "class", "doc": "<p>A <code>StateHandler</code> defines functions that are invoked at certain periods\nduring the lifetime of the state machine. State handlers are registered\nwith the main state machine loop so that they are executed when the game\nenters a given state.</p>\n\n<p>Each function takes a <code>StateHandlerContext</code> so that there are no\nlimitations as to what a state handler can do at any point during its\nlifetime.</p>\n"}, {"fullname": "game_state.StateHandler.__init__", "modulename": "game_state", "qualname": "StateHandler.__init__", "kind": "function", "doc": "<p>Construct a new <code>StateHandler</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span>)</span>"}, {"fullname": "game_state.StateHandler.on_enter", "modulename": "game_state", "qualname": "StateHandler.on_enter", "kind": "function", "doc": "<p>This function is invoked at the rising edge of a state transition. A\nstate transition occurs either when the main loop begins, or after a\nprevious state yielded its control of the state machine. It is invoked\n<em>before</em> <code>process()</code> exactly once per state transition.</p>\n\n<p>For our application, this function is primarily used to draw Pygame\nGUI components onto the screen for the current state, since they only\nneed to be registered with the <code>UIManager</code> once.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "game_state.StateHandler.process", "modulename": "game_state", "qualname": "StateHandler.process", "kind": "function", "doc": "<p>This function is invoked iteratively at a fixed frame\nrate&mdash;though this rate should be assumed to be\nunknown&mdash;for the entire duration that the state machine remains\nin the current state. It is always invoked after <code>on_enter()</code> and\nbefore <code>on_exit()</code>, although it may be executed many times between each\nof those invocations.</p>\n\n<p>For our application, this function is primarily used to draw the game\nscene and process user input.</p>\n\n<p>This function should return the next state that the state machine\nshould enter. If the state machine should remain in the same state, it\nshould return <code>context.get_state()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span><span class=\"return-annotation\">) -> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">GameState</span>:</span></span>", "funcdef": "def"}, {"fullname": "game_state.StateHandler.on_exit", "modulename": "game_state", "qualname": "StateHandler.on_exit", "kind": "function", "doc": "<p>This function is invoked at the falling edge of a state transition. It\noperates just like <code>on_enter()</code>, except it is executed when the current\nstate indicates that it would like to transition to another state. This\nallows the state handler to clean up anything as necessary.</p>\n\n<p>For our application, this function is primarily used to reset\nPygame GUI for each screen, as well as any state that should not carry\nover the next time this state is entered.</p>\n\n<p>By default, <code>on_exit()</code> will clear the Pygame GUI, so individual state\nhandlers need only register their components on enter; they don't have\nto worry about de-registering them on exit. Note, of course, that this\nfunction may be overridden and thus not execute if the child function\ndoes not make a call to <code>super().on_exit()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "log", "modulename": "log", "kind": "module", "doc": "<p>log module: A simple logging facility intended to be used to log messages to\nthe console or a log file. It may be extended in the future, but for now\nis intended to define a stable interface with which messages can be\nlogged such that, if the log format needs to change in the future, it\ncan easily be changed in only one spot and all log messages will be\nupdated accordingly.</p>\n"}, {"fullname": "log.DEBUG", "modulename": "log", "qualname": "DEBUG", "kind": "variable", "doc": "<p>Debug messages are intended only for developers and should be disabled in\nproduction.</p>\n", "default_value": "10"}, {"fullname": "log.INFO", "modulename": "log", "qualname": "INFO", "kind": "variable", "doc": "<p>Info messages are informative to users and developers.</p>\n", "default_value": "20"}, {"fullname": "log.WARNING", "modulename": "log", "qualname": "WARNING", "kind": "variable", "doc": "<p>Notify the user that something is wrong. Note that this is a non-fatal\ncondition, and that the user can't be reasonably expected to actually check\nthis since users might not even be running the program in a terminal. If the\nwarning must be presented to the user, it must be drawn in the GUI.</p>\n", "default_value": "30"}, {"fullname": "log.ERROR", "modulename": "log", "qualname": "ERROR", "kind": "variable", "doc": "<p>Notify the user that something is <em>very</em> wrong. Same statements apply as\nnoted in <code>WARNING</code>.</p>\n", "default_value": "40"}, {"fullname": "log.CRITICAL", "modulename": "log", "qualname": "CRITICAL", "kind": "variable", "doc": "<p>Only use this if you are about to abort the program immediately after\nwriting the message.</p>\n", "default_value": "50"}, {"fullname": "log.Log", "modulename": "log", "qualname": "Log", "kind": "class", "doc": "<p>The <code>Log</code> class provides all the logging functionality. Note\nthat there is a global log instance accessible via the global\n<code>get_logger()</code> function, so this class will not normally be\ninstantiated by outside code.</p>\n"}, {"fullname": "log.Log.__init__", "modulename": "log", "qualname": "Log.__init__", "kind": "function", "doc": "<p>Initialize the logging class with an initial log level.\nMessages with a lower log level will not be displayed. The\nlog level can be changed with setLevel() after the class is\nconstructed.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">level</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "log.Log.set_level", "modulename": "log", "qualname": "Log.set_level", "kind": "function", "doc": "<p>Set the log level, above which to log messages as they show\nup. Messages with a lower log level will not be displayed.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">level</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "log.Log.get_level", "modulename": "log", "qualname": "Log.get_level", "kind": "function", "doc": "<p>Get the current log level.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "log.Log.msg", "modulename": "log", "qualname": "Log.msg", "kind": "function", "doc": "<p>Log a message to the output. The message is prefaced with a\nstring representation of the log level, the function and module\nfrom which the log call was made, and the message itself, in\nthat order.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">level</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "log.get_logger", "modulename": "log", "qualname": "get_logger", "kind": "function", "doc": "<p>Get the default logger. All code should use this logger; that is,\nthere should only ever be one instance of the Log class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"n\">Log</span>:</span></span>", "funcdef": "def"}, {"fullname": "log.msg", "modulename": "log", "qualname": "msg", "kind": "function", "doc": "<p>A shorthand for <code>log.get_logger().msg()</code> that allows the syntax\n<code>log.msg()</code> to be used.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">level</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "user_data", "modulename": "user_data", "kind": "module", "doc": "<p>Persist a Python dictionary across program executions. This module\nprovides the UserData class, which allows the program to store data without\nregard for how it ends up in persistent storage.</p>\n\n<p>Note that you should use user_data.get() to get the default instance of\nUserData instead of instantiating it yourself in most cases, although you\nmay wish to instantiate a new UserData with a different store location.</p>\n"}, {"fullname": "user_data.UserData", "modulename": "user_data", "qualname": "UserData", "kind": "class", "doc": "<p>UserData is a simple dictionary-like class that persists its keys and\nvalues to the disk in JSON format. The logic for persisting values is\nentirely abstracted away such that any data inserted into the store is\nautomatically persisted without further caller intervention.</p>\n\n<p>This class currently provides no method for tuning the cache lifetime or\nwrite frequency; the persistent storage is written immediately when data\nis pushed with __setitem__().</p>\n\n<p>Data is accessed and persisted exactly as if the object were a\ndictionary, so use the Python dictionary syntax to store data.</p>\n"}, {"fullname": "user_data.UserData.__init__", "modulename": "user_data", "qualname": "UserData.__init__", "kind": "function", "doc": "<p>Construct a new persistent user data store. The passed parameter\nshould be a path from which data will be loaded and into which data\nwill be stored transparently. Note that only one UserData class can\ncorrespond to a single file on the disk at a time, and runtime\nchecks are in place to ensure this is the case.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">store</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span></span>)</span>"}, {"fullname": "user_data.UserData.get_data_dir", "modulename": "user_data", "qualname": "UserData.get_data_dir", "kind": "function", "doc": "<p>Get the application data directory in a platform-agnostic manner.\nThis function supports Windows, Linux, and MacOS, although I am\nunfamiliar with MacOS so I don't know if I got the directory correct.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>:</span></span>", "funcdef": "def"}, {"fullname": "user_data.UserData.snapshot", "modulename": "user_data", "qualname": "UserData.snapshot", "kind": "function", "doc": "<p>Take a snapshot of the currently cached dictionary, returning a new\ndictionary that is totally independent of the user data, which means\nthat updates to the dictionary returned by this function do not affect\nthe actual user data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "user_data.UserData.get_path", "modulename": "user_data", "qualname": "UserData.get_path", "kind": "function", "doc": "<p>Get the name of the file backing this persistent user data store.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>:</span></span>", "funcdef": "def"}, {"fullname": "user_data.UserData.close", "modulename": "user_data", "qualname": "UserData.close", "kind": "function", "doc": "<p>When a UserData store is no longer in use, this function should be\ncalled on it to notify the system that the handle can be closed.\nThis flushes the cache and allows the user to create new UserData\nstores in the future that are backed by the same file as this one was.</p>\n\n<p>Note that closed stores can no longer be used; they must be re-created.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "user_data.get", "modulename": "user_data", "qualname": "get", "kind": "function", "doc": "<p>Get the global, default UserData store. This is the one that should be\nused for most purposes; it is unlikely that you will have to manually\ncreate new UserData stores. Note that this store should be closed before\nthe program exits.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">user_data</span><span class=\"o\">.</span><span class=\"n\">UserData</span>:</span></span>", "funcdef": "def"}, {"fullname": "DifficultyHandler", "modulename": "DifficultyHandler", "kind": "module", "doc": "<p>This handler handles the <code>DIFFICULTY</code> state, which allows the user to select\nthe difficulty of the game in math mode. The game offers four difficulties:</p>\n\n<ul>\n<li>Easy</li>\n<li>Medium</li>\n<li>Hard</li>\n<li>Infinite</li>\n</ul>\n"}, {"fullname": "DifficultyHandler.DifficultyHandler", "modulename": "DifficultyHandler", "qualname": "DifficultyHandler", "kind": "class", "doc": "<p>A <code>StateHandler</code> defines functions that are invoked at certain periods\nduring the lifetime of the state machine. State handlers are registered\nwith the main state machine loop so that they are executed when the game\nenters a given state.</p>\n\n<p>Each function takes a <code>StateHandlerContext</code> so that there are no\nlimitations as to what a state handler can do at any point during its\nlifetime.</p>\n", "bases": "game_state.StateHandler"}, {"fullname": "DifficultyHandler.DifficultyHandler.__init__", "modulename": "DifficultyHandler", "qualname": "DifficultyHandler.__init__", "kind": "function", "doc": "<p>Construct a new <code>StateHandler</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span>)</span>"}, {"fullname": "DifficultyHandler.DifficultyHandler.process", "modulename": "DifficultyHandler", "qualname": "DifficultyHandler.process", "kind": "function", "doc": "<p>This function is invoked iteratively at a fixed frame\nrate&mdash;though this rate should be assumed to be\nunknown&mdash;for the entire duration that the state machine remains\nin the current state. It is always invoked after <code>on_enter()</code> and\nbefore <code>on_exit()</code>, although it may be executed many times between each\nof those invocations.</p>\n\n<p>For our application, this function is primarily used to draw the game\nscene and process user input.</p>\n\n<p>This function should return the next state that the state machine\nshould enter. If the state machine should remain in the same state, it\nshould return <code>context.get_state()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span><span class=\"return-annotation\">) -> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">GameState</span>:</span></span>", "funcdef": "def"}, {"fullname": "GameModeHandler", "modulename": "GameModeHandler", "kind": "module", "doc": "<p>This handler handles the <code>GAME_MODE</code> state, which allows the user to select\neither math mode or flashcard mode.</p>\n"}, {"fullname": "GameModeHandler.GameModeHandler", "modulename": "GameModeHandler", "qualname": "GameModeHandler", "kind": "class", "doc": "<p>A <code>StateHandler</code> defines functions that are invoked at certain periods\nduring the lifetime of the state machine. State handlers are registered\nwith the main state machine loop so that they are executed when the game\nenters a given state.</p>\n\n<p>Each function takes a <code>StateHandlerContext</code> so that there are no\nlimitations as to what a state handler can do at any point during its\nlifetime.</p>\n", "bases": "game_state.StateHandler"}, {"fullname": "GameModeHandler.GameModeHandler.__init__", "modulename": "GameModeHandler", "qualname": "GameModeHandler.__init__", "kind": "function", "doc": "<p>Construct a new <code>StateHandler</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span>)</span>"}, {"fullname": "GameModeHandler.GameModeHandler.process", "modulename": "GameModeHandler", "qualname": "GameModeHandler.process", "kind": "function", "doc": "<p>This function is invoked iteratively at a fixed frame\nrate&mdash;though this rate should be assumed to be\nunknown&mdash;for the entire duration that the state machine remains\nin the current state. It is always invoked after <code>on_enter()</code> and\nbefore <code>on_exit()</code>, although it may be executed many times between each\nof those invocations.</p>\n\n<p>For our application, this function is primarily used to draw the game\nscene and process user input.</p>\n\n<p>This function should return the next state that the state machine\nshould enter. If the state machine should remain in the same state, it\nshould return <code>context.get_state()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span><span class=\"return-annotation\">) -> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">GameState</span>:</span></span>", "funcdef": "def"}, {"fullname": "LevelEndHandler", "modulename": "LevelEndHandler", "kind": "module", "doc": "<p>This handler handles the <code>LEVEL_END</code> state, which is entered when the user dies\neither by hitting an obstacle because the equation was solved too slowly, or\nthe user answered the equation incorrectly.</p>\n\n<p>This handler is responsible for displaying the end game menu, which prompts the\nplayer with a few buttons similar to the main menu.</p>\n"}, {"fullname": "LevelEndHandler.LevelEndHandler", "modulename": "LevelEndHandler", "qualname": "LevelEndHandler", "kind": "class", "doc": "<p>A <code>StateHandler</code> defines functions that are invoked at certain periods\nduring the lifetime of the state machine. State handlers are registered\nwith the main state machine loop so that they are executed when the game\nenters a given state.</p>\n\n<p>Each function takes a <code>StateHandlerContext</code> so that there are no\nlimitations as to what a state handler can do at any point during its\nlifetime.</p>\n", "bases": "game_state.StateHandler"}, {"fullname": "LevelEndHandler.LevelEndHandler.__init__", "modulename": "LevelEndHandler", "qualname": "LevelEndHandler.__init__", "kind": "function", "doc": "<p>Construct a new <code>StateHandler</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span>)</span>"}, {"fullname": "LevelEndHandler.LevelEndHandler.on_enter", "modulename": "LevelEndHandler", "qualname": "LevelEndHandler.on_enter", "kind": "function", "doc": "<p>This function is invoked at the rising edge of a state transition. A\nstate transition occurs either when the main loop begins, or after a\nprevious state yielded its control of the state machine. It is invoked\n<em>before</em> <code>process()</code> exactly once per state transition.</p>\n\n<p>For our application, this function is primarily used to draw Pygame\nGUI components onto the screen for the current state, since they only\nneed to be registered with the <code>UIManager</code> once.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "LevelEndHandler.LevelEndHandler.process", "modulename": "LevelEndHandler", "qualname": "LevelEndHandler.process", "kind": "function", "doc": "<p>This function is invoked iteratively at a fixed frame\nrate&mdash;though this rate should be assumed to be\nunknown&mdash;for the entire duration that the state machine remains\nin the current state. It is always invoked after <code>on_enter()</code> and\nbefore <code>on_exit()</code>, although it may be executed many times between each\nof those invocations.</p>\n\n<p>For our application, this function is primarily used to draw the game\nscene and process user input.</p>\n\n<p>This function should return the next state that the state machine\nshould enter. If the state machine should remain in the same state, it\nshould return <code>context.get_state()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span><span class=\"return-annotation\">) -> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">GameState</span>:</span></span>", "funcdef": "def"}, {"fullname": "LevelPauseHandler", "modulename": "LevelPauseHandler", "kind": "module", "doc": "<p>This handler handles the <code>LEVEL_PAUSE</code> state, which is invoked by the user\nduring game play and allows the user to pause the state of the game. This\nhandler specifically displays the pause screen and allows the user to resume\nor abort the current level.</p>\n"}, {"fullname": "LevelPauseHandler.LevelPauseHandler", "modulename": "LevelPauseHandler", "qualname": "LevelPauseHandler", "kind": "class", "doc": "<p>A <code>StateHandler</code> defines functions that are invoked at certain periods\nduring the lifetime of the state machine. State handlers are registered\nwith the main state machine loop so that they are executed when the game\nenters a given state.</p>\n\n<p>Each function takes a <code>StateHandlerContext</code> so that there are no\nlimitations as to what a state handler can do at any point during its\nlifetime.</p>\n", "bases": "game_state.StateHandler"}, {"fullname": "LevelPauseHandler.LevelPauseHandler.__init__", "modulename": "LevelPauseHandler", "qualname": "LevelPauseHandler.__init__", "kind": "function", "doc": "<p>Construct a new <code>StateHandler</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span>)</span>"}, {"fullname": "LevelPauseHandler.LevelPauseHandler.process", "modulename": "LevelPauseHandler", "qualname": "LevelPauseHandler.process", "kind": "function", "doc": "<p>This function is invoked iteratively at a fixed frame\nrate&mdash;though this rate should be assumed to be\nunknown&mdash;for the entire duration that the state machine remains\nin the current state. It is always invoked after <code>on_enter()</code> and\nbefore <code>on_exit()</code>, although it may be executed many times between each\nof those invocations.</p>\n\n<p>For our application, this function is primarily used to draw the game\nscene and process user input.</p>\n\n<p>This function should return the next state that the state machine\nshould enter. If the state machine should remain in the same state, it\nshould return <code>context.get_state()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span><span class=\"return-annotation\">) -> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">GameState</span>:</span></span>", "funcdef": "def"}, {"fullname": "LevelPlayHandler", "modulename": "LevelPlayHandler", "kind": "module", "doc": "<p>This handler handles the <code>LEVEL_PLAY</code> state, which is the actual core of the\ngame logic. In this handler, the user actually plays the game by answering\nquestions and causing the character to jump. This handler keeps track of score\nand updates the scene by scrolling it to the left.</p>\n"}, {"fullname": "LevelPlayHandler.LevelPlayHandler", "modulename": "LevelPlayHandler", "qualname": "LevelPlayHandler", "kind": "class", "doc": "<p>A <code>StateHandler</code> defines functions that are invoked at certain periods\nduring the lifetime of the state machine. State handlers are registered\nwith the main state machine loop so that they are executed when the game\nenters a given state.</p>\n\n<p>Each function takes a <code>StateHandlerContext</code> so that there are no\nlimitations as to what a state handler can do at any point during its\nlifetime.</p>\n", "bases": "src.game_state.StateHandler"}, {"fullname": "LevelPlayHandler.LevelPlayHandler.__init__", "modulename": "LevelPlayHandler", "qualname": "LevelPlayHandler.__init__", "kind": "function", "doc": "<p>Construct a new <code>StateHandler</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span>)</span>"}, {"fullname": "LevelPlayHandler.LevelPlayHandler.on_enter", "modulename": "LevelPlayHandler", "qualname": "LevelPlayHandler.on_enter", "kind": "function", "doc": "<p>This function is invoked at the rising edge of a state transition. A\nstate transition occurs either when the main loop begins, or after a\nprevious state yielded its control of the state machine. It is invoked\n<em>before</em> <code>process()</code> exactly once per state transition.</p>\n\n<p>For our application, this function is primarily used to draw Pygame\nGUI components onto the screen for the current state, since they only\nneed to be registered with the <code>UIManager</code> once.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "LevelPlayHandler.LevelPlayHandler.process", "modulename": "LevelPlayHandler", "qualname": "LevelPlayHandler.process", "kind": "function", "doc": "<p>This function is invoked iteratively at a fixed frame\nrate&mdash;though this rate should be assumed to be\nunknown&mdash;for the entire duration that the state machine remains\nin the current state. It is always invoked after <code>on_enter()</code> and\nbefore <code>on_exit()</code>, although it may be executed many times between each\nof those invocations.</p>\n\n<p>For our application, this function is primarily used to draw the game\nscene and process user input.</p>\n\n<p>This function should return the next state that the state machine\nshould enter. If the state machine should remain in the same state, it\nshould return <code>context.get_state()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span><span class=\"return-annotation\">) -> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">GameState</span>:</span></span>", "funcdef": "def"}, {"fullname": "LevelPlayHandler.LevelPlayHandler.on_exit", "modulename": "LevelPlayHandler", "qualname": "LevelPlayHandler.on_exit", "kind": "function", "doc": "<p>This function is invoked at the falling edge of a state transition. It\noperates just like <code>on_enter()</code>, except it is executed when the current\nstate indicates that it would like to transition to another state. This\nallows the state handler to clean up anything as necessary.</p>\n\n<p>For our application, this function is primarily used to reset\nPygame GUI for each screen, as well as any state that should not carry\nover the next time this state is entered.</p>\n\n<p>By default, <code>on_exit()</code> will clear the Pygame GUI, so individual state\nhandlers need only register their components on enter; they don't have\nto worry about de-registering them on exit. Note, of course, that this\nfunction may be overridden and thus not execute if the child function\ndoes not make a call to <code>super().on_exit()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">context</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "MainMenuHandler", "modulename": "MainMenuHandler", "kind": "module", "doc": "<p>This handler handles the <code>MAIN_MENU</code> state. It displays the main menu and waits\nfor the user to make a selection.</p>\n"}, {"fullname": "MainMenuHandler.Button", "modulename": "MainMenuHandler", "qualname": "Button", "kind": "class", "doc": "<p>A simple class that represents a Pygame button. Note that this class does\n<em>not</em> use the Pygame GUI module; rather, it simply blits an image to the\nwindow and monitors incoming events to know if that area was clicked. In\nthe future, this class may be a proper button class that takes button text\nand color instead of an image.</p>\n"}, {"fullname": "MainMenuHandler.Button.__init__", "modulename": "MainMenuHandler", "qualname": "Button.__init__", "kind": "function", "doc": "<p>Create a new Button using <code>image</code> as the background and <code>text</code> as the\ntext.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">text</span></span>)</span>"}, {"fullname": "MainMenuHandler.Button.blit", "modulename": "MainMenuHandler", "qualname": "Button.blit", "kind": "function", "doc": "<p>Draw the button image on the screen.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">window</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "MainMenuHandler.Button.dispatch_event", "modulename": "MainMenuHandler", "qualname": "Button.dispatch_event", "kind": "function", "doc": "<p>Receive an event from the processor context and use it to determine\nwhether this button was clicked, returning <code>False</code> if this event does\nnot indicate a click of this button and <code>True</code> if it does.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">event</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "MainMenuHandler.MainMenuHandler", "modulename": "MainMenuHandler", "qualname": "MainMenuHandler", "kind": "class", "doc": "<p>A <code>StateHandler</code> defines functions that are invoked at certain periods\nduring the lifetime of the state machine. State handlers are registered\nwith the main state machine loop so that they are executed when the game\nenters a given state.</p>\n\n<p>Each function takes a <code>StateHandlerContext</code> so that there are no\nlimitations as to what a state handler can do at any point during its\nlifetime.</p>\n", "bases": "game_state.StateHandler"}, {"fullname": "MainMenuHandler.MainMenuHandler.__init__", "modulename": "MainMenuHandler", "qualname": "MainMenuHandler.__init__", "kind": "function", "doc": "<p>Construct a new <code>StateHandler</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span>)</span>"}, {"fullname": "MainMenuHandler.MainMenuHandler.process", "modulename": "MainMenuHandler", "qualname": "MainMenuHandler.process", "kind": "function", "doc": "<p>This function is invoked iteratively at a fixed frame\nrate&mdash;though this rate should be assumed to be\nunknown&mdash;for the entire duration that the state machine remains\nin the current state. It is always invoked after <code>on_enter()</code> and\nbefore <code>on_exit()</code>, although it may be executed many times between each\nof those invocations.</p>\n\n<p>For our application, this function is primarily used to draw the game\nscene and process user input.</p>\n\n<p>This function should return the next state that the state machine\nshould enter. If the state machine should remain in the same state, it\nshould return <code>context.get_state()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span><span class=\"return-annotation\">) -> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">GameState</span>:</span></span>", "funcdef": "def"}, {"fullname": "QuitHandler", "modulename": "QuitHandler", "kind": "module", "doc": "<p>This handler is a stub handler that handles the <code>GAME_QUIT</code> state by doing\nnothing but keeping the state machine in <code>GAME_QUIT</code>, because the main state\nmachine loop is responsible for terminating itself when <code>GAME_QUIT</code> is entered,\nhowever a handler must still be executed.</p>\n"}, {"fullname": "QuitHandler.QuitHandler", "modulename": "QuitHandler", "qualname": "QuitHandler", "kind": "class", "doc": "<p>A <code>StateHandler</code> defines functions that are invoked at certain periods\nduring the lifetime of the state machine. State handlers are registered\nwith the main state machine loop so that they are executed when the game\nenters a given state.</p>\n\n<p>Each function takes a <code>StateHandlerContext</code> so that there are no\nlimitations as to what a state handler can do at any point during its\nlifetime.</p>\n", "bases": "game_state.StateHandler"}, {"fullname": "QuitHandler.QuitHandler.process", "modulename": "QuitHandler", "qualname": "QuitHandler.process", "kind": "function", "doc": "<p>This function is invoked iteratively at a fixed frame\nrate&mdash;though this rate should be assumed to be\nunknown&mdash;for the entire duration that the state machine remains\nin the current state. It is always invoked after <code>on_enter()</code> and\nbefore <code>on_exit()</code>, although it may be executed many times between each\nof those invocations.</p>\n\n<p>For our application, this function is primarily used to draw the game\nscene and process user input.</p>\n\n<p>This function should return the next state that the state machine\nshould enter. If the state machine should remain in the same state, it\nshould return <code>context.get_state()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span><span class=\"return-annotation\">) -> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">GameState</span>:</span></span>", "funcdef": "def"}, {"fullname": "ScoreHandler", "modulename": "ScoreHandler", "kind": "module", "doc": "<p>This handler handles the <code>SCORE</code> state, in which the game presents the user\nwith the top 5 and most recent 5 scores for infinite math mode and flashcard\nmode. The scores include a numerical component that represents how many\nquestions were answered successfully, as well as the amount of time that\nelapsed. Higher scores and higher times are better.</p>\n"}, {"fullname": "ScoreHandler.ScoreHandler", "modulename": "ScoreHandler", "qualname": "ScoreHandler", "kind": "class", "doc": "<p>A <code>StateHandler</code> defines functions that are invoked at certain periods\nduring the lifetime of the state machine. State handlers are registered\nwith the main state machine loop so that they are executed when the game\nenters a given state.</p>\n\n<p>Each function takes a <code>StateHandlerContext</code> so that there are no\nlimitations as to what a state handler can do at any point during its\nlifetime.</p>\n", "bases": "game_state.StateHandler"}, {"fullname": "ScoreHandler.ScoreHandler.__init__", "modulename": "ScoreHandler", "qualname": "ScoreHandler.__init__", "kind": "function", "doc": "<p>Construct a new <code>StateHandler</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span>)</span>"}, {"fullname": "ScoreHandler.ScoreHandler.process", "modulename": "ScoreHandler", "qualname": "ScoreHandler.process", "kind": "function", "doc": "<p>This function is invoked iteratively at a fixed frame\nrate&mdash;though this rate should be assumed to be\nunknown&mdash;for the entire duration that the state machine remains\nin the current state. It is always invoked after <code>on_enter()</code> and\nbefore <code>on_exit()</code>, although it may be executed many times between each\nof those invocations.</p>\n\n<p>For our application, this function is primarily used to draw the game\nscene and process user input.</p>\n\n<p>This function should return the next state that the state machine\nshould enter. If the state machine should remain in the same state, it\nshould return <code>context.get_state()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">StateHandlerContext</span></span><span class=\"return-annotation\">) -> <span class=\"n\">game_state</span><span class=\"o\">.</span><span class=\"n\">GameState</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();